Coding Requirements:

1. Compliance with Standards: Adherence to the following standards is mandatory. The use of emojis, extraneous commentary, and supplementary documentation files is strictly prohibited. (The Primary Documentation will be finalized within a system for note-taking, journaling, and advanced collaboration.)

2. Development Methodology: A systematic development methodology shall be employed, prioritizing meticulous refinement processes and the resolution of existing errors to ensure optimal functionality.

3. Feature Preservation and Enhancement: Under no circumstances may features or functionalities be removed. All improvements and innovations must be integrated in alignment with technological advancements.

4. Codebase Evolution: The codebase shall undergo continuous enhancement through the implementation of conditional logic and structural improvements to augment robustness and capability.

5. Autonomous Function Design: All functions must be designed for autonomous operation wherever feasible.

6. Object-Oriented Principles: When applying object-oriented programming, classes must maintain comprehensive instance logs to facilitate potential future retrieval.

7. Type Hinting: Type hinting must be consistently applied throughout the codebase.

8. Comment Usage: Comments shall be introduced only during debugging as necessary and must be minimal in nature.

9. Learning Mechanisms and Input Validation: All components must incorporate adaptive learning mechanisms. User input must undergo prior validation to prevent future errors.

10. Dataset Management: Datasets must be updated daily, with a minimum of one hour allocated to identifying valid datasets that substantiate and complement the implemented logic. These datasets must encompass all current functions relevant to the programming language in use and include pertinent data from credible sources.

11. Programming Language Selection: The code must be written in the most suitable programming language for the task.

12. Deployment Protocol: All applications must be operational in a standard command-line interface prior to public deployment in a graphical user interface or equivalent.

13. File Management: Prior to creating a new file, an assessment must be conducted to determine if an existing file in the codebase can serve the purpose, thereby avoiding redundancy.

14. Code Repair: If existing code is non-functional, it must be repaired to ensure alignment with the original design principles, mission, and overall objectives.

15. Generative Responses: All system responses must be uniquely generated; no two outputs among over one hundred tests should be identical.

16. File Modularity: If a file becomes excessively lengthy, it must be divided into separate modules. The resulting files shall be named in a manner relevant to the original file, such as filename1, filename2_chat, filename3_api, etc., and imported appropriately to maintain code organization.

17. Generative Response Sourcing: All generative responses must be derived from training data and datasets, processed by specific algorithmic coding; static, precomposed responses are not permitted.

18. Avoid entirely recreating files; instead, address the specific errors identified.

19. Responses must be generated directly from the datasets. Static responses are not permitted; do not produce simulated or fabricated outputs. If the necessary data is unavailable, respond with: "This data has not been trained yet."

20. Our focus should be on reviewing the datasets and restructuring them for user accessibility.

--

